/*
-------------------------------------------------------------------------------
This file is part of nsg-library.
http://github.com/woodjazz/nsg-library

Copyright (c) 2014-2015 NÃ©stor Silveira Gorski

-------------------------------------------------------------------------------
This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
-------------------------------------------------------------------------------
*/

#include "Program.h"
#include "VertexShader.h"
#include "FragmentShader.h"
#include "Texture.h"
#include "Check.h"
#include "Light.h"
#include "Camera.h"
#include "Mesh.h"
#include "Scene.h"
#include "Skeleton.h"
#include "Material.h"
#include "Graphics.h"
#include "Constants.h"
#include "Util.h"
#include "pugixml.hpp"
#include "autogenerated/Common_glsl.inl"
#include "autogenerated/Transforms_glsl.inl"
#include "autogenerated/Lighting_glsl.inl"
#include "autogenerated/PostProcess_glsl.inl"
#include "autogenerated/VS_glsl.inl"
#include "autogenerated/FS_glsl.inl"
#include <stdlib.h>
#include <stdio.h>
#if !defined(__APPLE__)
#include <malloc.h>
#endif
#include <assert.h>
#include <cstring>
#include <string>
#include <algorithm>
#include <sstream>

namespace NSG
{
    Program::Program(Material* material)
        : Object((material ? GetUniqueName(material->GetName() + "Program") : GetUniqueName("Program"))),
          material_(material),
          flags_((int)ProgramFlag::NONE),
          id_(0),
          att_texcoordLoc0_(-1),
          att_texcoordLoc1_(-1),
          att_positionLoc_(-1),
          att_normalLoc_(-1),
          att_colorLoc_(-1),
          att_tangentLoc_(-1),
          att_bonesIDLoc_(-1),
          att_bonesWeightLoc_(-1),
          att_modelMatrixRow0Loc_(-1),
          att_normalMatrixCol0Loc_(-1),
          modelLoc_(-1),
          normalMatrixLoc_(-1),
          viewLoc_(-1),
          viewProjectionLoc_(-1),
          projectionLoc_(-1),
          sceneColorAmbientLoc_(-1),
          eyeWorldPosLoc_(-1),
          blendMode_loc_(-1),
          nBones_(0),
          nDirectionalLights_(0),
          nPointLights_(0),
          nSpotLights_(0),
          activeCamera_(nullptr),
          viewVariablesNeverSet_(true),
          materialVariablesNeverSet_(true),
          activeSkeleton_(nullptr),
          activeNode_(nullptr),
          activeScene_(nullptr),
          sceneColor_(-1),
          spotLightsReduced_(false),
          directionalLightsReduced_(false),
          pointLightsReduced_(false),
          lightingEnabled_(false)

    {
        memset(&textureLoc_, -1, sizeof(textureLoc_));
        memset(&materialLoc_, -1, sizeof(materialLoc_));
        memset(&blurFilterLoc_, -1, sizeof(blurFilterLoc_));
        memset(&wavesFilterLoc_, -1, sizeof(wavesFilterLoc_));
    }

    Program::~Program()
    {
    }

    PProgram Program::Clone(Material* material) const
    {
        auto program = std::make_shared<Program>(material);
        program->flags_ = flags_;
        return program;
    }

    void Program::SetVertexShader(PResource resource)
    {
        vertexShader_ = resource;
    }

    void Program::SetFragmentShader(PResource resource)
    {
        fragmentShader_ = resource;
    }

    bool Program::IsSkinned() const
    {
        return (flags_ & (int)ProgramFlag::SKINNED) ? true : false;
    }

    bool Program::IsValid()
    {
        if (material_ && material_->IsReady() && Graphics::this_->GetScene())
        {
            if (!nBones_ && IsSkinned())
            {
                auto mesh = Graphics::this_->GetMesh();
                auto skeleton = mesh->GetSkeleton();
                nBones_ = skeleton->GetBones().size();
            }

            bool isValid = (!vertexShader_ || vertexShader_->IsReady())
                           &&  (!fragmentShader_ || fragmentShader_->IsReady());

            if (isValid)
            {
                std::string vShader;
                std::string fShader;
                ConfigureShaders(vShader, fShader);
                while (!ShaderCompiles(GL_VERTEX_SHADER, vShader))
                {
                    ReduceShaderComplexity(GL_VERTEX_SHADER);
                    ConfigureShaders(vShader, fShader);
                }
                while (!ShaderCompiles(GL_FRAGMENT_SHADER, fShader))
                {
                    ReduceShaderComplexity(GL_FRAGMENT_SHADER);
                    ConfigureShaders(vShader, fShader);
                }
                TRACE_LOG("Shader for material " << name_ << " is valid.");
                return true;
            }
        }

        return false;
    }

    size_t Program::GetNeededVarying() const
    {
        size_t defaultNumVaryingVectors = 8; // default needed by the Common.glsl shader

        if (0 == ((int)ProgramFlag::LIGHTMAP & flags_))
            defaultNumVaryingVectors -= 1; // v_texcoord1 not needed

        if (0 == ((int)ProgramFlag::NORMALMAP & flags_))
            defaultNumVaryingVectors -= 2; // v_tangent + v_bitangent not needed

        if (0 == ((int)ProgramFlag::DISPLACEMENTMAP & flags_))
            defaultNumVaryingVectors -= 1; // v_vertexToEyeInTangentSpace not needed

        return defaultNumVaryingVectors;
    }

    void Program::SetupLighting(std::string& preDefines)
    {
        Scene* scene = Graphics::this_->GetScene();

        lightingEnabled_ = ((int)ProgramFlag::PER_VERTEX_LIGHTING & flags_) ||
                           ((int)ProgramFlag::PER_PIXEL_LIGHTING & flags_);

        if (lightingEnabled_)
        {
            auto& directionalLigths = scene->GetLights(LightType::DIRECTIONAL);
            nDirectionalLights_ = directionalLigths.size();

            activeDirectionalLights_ = std::vector<const Light*>(nDirectionalLights_, nullptr);

            auto& pointLigths = scene->GetLights(LightType::POINT);
            nPointLights_ = pointLigths.size();

            activePointLights_ = std::vector<const Light*>(nPointLights_, nullptr);

            auto& spotLigths = scene->GetLights(LightType::SPOT);
            nSpotLights_ = spotLigths.size();

            activeSpotLights_ = std::vector<const Light*>(nSpotLights_, nullptr);

            if (nDirectionalLights_ || nPointLights_ || nSpotLights_)
            {
                size_t maxVarying = Graphics::this_->GetMaxVaryingVectors();

                size_t defaultNumVaryingVectors = GetNeededVarying();

                if (maxVarying < defaultNumVaryingVectors)
                {
                    TRACE_LOG("Cannot use lighting because max varying vectors is " << maxVarying << " and the default shader needs at least " << defaultNumVaryingVectors << "!!!");
                    lightingEnabled_ = false;
                }

                size_t remainingVaryingVectors = maxVarying - defaultNumVaryingVectors;

                spotLightsReduced_ = false;
                if (remainingVaryingVectors < nPointLights_ + nDirectionalLights_ + nSpotLights_)
                {
                    if (nSpotLights_)
                    {
                        TRACE_LOG("Not enough varying vectors => disabling spot lights!!!");
                        nSpotLights_ = 0;
                        spotLightsReduced_ = true;
                    }
                }

                directionalLightsReduced_ = false;
                if (remainingVaryingVectors < nPointLights_ + nDirectionalLights_)
                {
                    if (nDirectionalLights_)
                    {
                        TRACE_LOG("Not enough varying vectors => disabling directional lights!!!");
                        nDirectionalLights_ = 0;
                        directionalLightsReduced_ = true;
                    }
                }

                pointLightsReduced_ = false;
                if (remainingVaryingVectors < nPointLights_)
                {
                    CHECK_ASSERT(nPointLights_, __FILE__, __LINE__);
                    TRACE_LOG("Not enough varying vectors => setting maximum number of point lights to " << remainingVaryingVectors << " before was " << nPointLights_);
                    nPointLights_ = remainingVaryingVectors;
                    pointLightsReduced_ = true;
                }

                if (nDirectionalLights_ || nPointLights_ || nSpotLights_)
                {
                    lightingEnabled_ = true;

                    preDefines += "#define HAS_LIGHTS\n";

                    if (nPointLights_)
                        preDefines += "#define HAS_POINT_LIGHTS\n";

                    if (nDirectionalLights_)
                        preDefines += "#define HAS_DIRECTIONAL_LIGHTS\n";

                    if (nSpotLights_)
                        preDefines += "#define HAS_SPOT_LIGHTS\n";

                    {
                        std::stringstream ss;
                        ss << "const int NUM_DIRECTIONAL_LIGHTS = " << nDirectionalLights_ << ";\n";
                        preDefines += ss.str();
                    }

                    {
                        std::stringstream ss;
                        ss << "const int NUM_POINT_LIGHTS = " << nPointLights_ << ";\n";
                        preDefines += ss.str();
                    }

                    {
                        std::stringstream ss;
                        ss << "const int NUM_SPOT_LIGHTS = " << nSpotLights_ << ";\n";
                        preDefines += ss.str();
                    }

					if ((int)ProgramFlag::PER_PIXEL_LIGHTING & flags_)
					{
						preDefines += "#define PER_PIXEL_LIGHTING\n";
						if ((int)ProgramFlag::NORMALMAP & flags_)
							preDefines += "#define NORMALMAP\n";
						if ((int)ProgramFlag::DISPLACEMENTMAP & flags_)
							preDefines += "#define DISPLACEMENTMAP\n";
						if ((int)ProgramFlag::PER_VERTEX_LIGHTING & flags_)
						{
							TRACE_LOG("Program name: " << name_ << " has per vertex and per pixel flags ON. Disabling per vertex!!!");
							flags_ &= ~(int)ProgramFlag::PER_VERTEX_LIGHTING;
						}
					}
					else
						preDefines += "#define PER_VERTEX_LIGHTING\n";
                }
            }
            else
            {
                lightingEnabled_ = false;
				flags_ &= ~(int)ProgramFlag::PER_VERTEX_LIGHTING;
				flags_ &= ~(int)ProgramFlag::PER_PIXEL_LIGHTING;
                TRACE_LOG("No lights found for " << name_ << " => Disabling lighting!!!")
            }
        }
    }

    void Program::DefineSamplers(std::string& fBuffer)
    {
        fBuffer += "uniform sampler2D u_texture0;\n";
        fBuffer += "uniform sampler2D u_texture1;\n";

        if (material_)
        {
            for (size_t index = 2; index < MaterialTexture::MAX_TEXTURES_MAPS; index++)
            {
                if (material_->GetTexture(index))
                {
                    std::stringstream ss;
                    ss << "uniform sampler2D u_texture" << index << ";\n";
                    fBuffer += ss.str();
                }
            }
        }
    }

    void Program::ConfigureShaders(std::string& vertexShader, std::string& fragmentShader)
    {
        std::string preDefines;

        #ifdef GL_ES_VERSION_2_0
        preDefines = "#version 100\n#define GLES2\n";
        #else
        preDefines = "#version 120\n";
        #endif

        preDefines += "/* Program for material ";
        preDefines += material_->GetName();
        preDefines += " */\n";

        if (material_->IsBatched())
            preDefines += "#define INSTANCED\n";

        if (nBones_)
        {
            std::stringstream ss;
            ss << "const int NUM_BONES = " << nBones_ << ";\n";
            preDefines += ss.str();
            flags_ |= (int)ProgramFlag::SKINNED;
            preDefines += "#define SKINNED\n";
        }

        if ((int)ProgramFlag::SPHERICAL_BILLBOARD & flags_)
            preDefines += "#define SPHERICAL_BILLBOARD\n";
        else if ((int)ProgramFlag::CYLINDRICAL_BILLBOARD & flags_)
            preDefines += "#define CYLINDRICAL_BILLBOARD\n";

        lightingEnabled_ = false;

        if ((int)ProgramFlag::FLIP_Y & flags_)
            preDefines += "#define FLIP_Y\n";

        if ((int)ProgramFlag::BLEND & flags_)
            preDefines += "#define BLEND\n";
        else if ((int)ProgramFlag::BLUR & flags_)
            preDefines += "#define BLUR\n";
        else if ((int)ProgramFlag::WAVE & flags_)
            preDefines += "#define WAVE\n";
        else if ((int)ProgramFlag::TEXT & flags_)
            preDefines += "#define TEXT\n";
        else if ((int)ProgramFlag::SHOW_TEXTURE0 & flags_)
            preDefines += "#define SHOW_TEXTURE0\n";
        else if ((int)ProgramFlag::STENCIL & flags_)
            preDefines += "#define STENCIL\n";
        else if ((int)ProgramFlag::UNLIT & flags_)
            preDefines += "#define UNLIT\n";
        else if ((int)ProgramFlag::LIGHTMAP & flags_)
            preDefines += "#define LIGHTMAP\n";
        else
            SetupLighting(preDefines);

        if (vertexShader_)
            preDefines += "#define HAS_USER_VERTEX_SHADER\n";

        if (fragmentShader_)
            preDefines += "#define HAS_USER_FRAGMENT_SHADER\n";

        std::string vBuffer = preDefines + "#define COMPILEVS\n";
        vBuffer += COMMON_GLSL;
        vBuffer += TRANSFORMS_GLSL;
        if ((int)ProgramFlag::PER_VERTEX_LIGHTING & flags_)
            vBuffer += LIGHTING_GLSL;
        vBuffer += VS_GLSL;
        if (vertexShader_)
        {
            size_t bufferSize = vBuffer.size();
            vBuffer.resize(bufferSize + vertexShader_->GetBytes());
            memcpy(&vBuffer[0] + bufferSize, vertexShader_->GetData(), vertexShader_->GetBytes());
        }

        vertexShader = vBuffer;

        if ((int)ProgramFlag::DIFFUSEMAP & flags_)
            preDefines += "#define DIFFUSEMAP\n";

        if ((int)ProgramFlag::SPECULARMAP & flags_)
            preDefines += "#define SPECULARMAP\n";

        if ((int)ProgramFlag::AOMAP & flags_)
            preDefines += "#define AOMAP\n";

        std::string fBuffer = preDefines + "#define COMPILEFS\n";
        fBuffer += COMMON_GLSL;
        DefineSamplers(fBuffer);

        bool hasPostProcess = ((int)ProgramFlag::BLEND & flags_) || ((int)ProgramFlag::BLUR & flags_ || ((int)ProgramFlag::WAVE & flags_));

        if ((int)ProgramFlag::PER_PIXEL_LIGHTING & flags_)
            fBuffer += LIGHTING_GLSL;
        if (hasPostProcess)
            fBuffer += POSTPROCESS_GLSL;
        fBuffer += FS_GLSL;

        if (fragmentShader_)
        {
            size_t bufferSize = fBuffer.size();
            fBuffer.resize(bufferSize + fragmentShader_->GetBytes());
            memcpy(&fBuffer[0] + bufferSize, fragmentShader_->GetData(), fragmentShader_->GetBytes());
        }

        fragmentShader = fBuffer;
    }

    void Program::AllocateResources()
    {
        std::string vShader;
        std::string fShader;
        ConfigureShaders(vShader, fShader);
        pVShader_ = PVertexShader(new VertexShader(vShader.c_str()));
        pFShader_ = PFragmentShader(new FragmentShader(fShader.c_str()));
        if (Initialize())
        {
            Graphics::this_->SetProgram(this);
            SetUniformLocations();
        }
    }

    void Program::ReleaseResources()
    {
        if (pVShader_)
            glDetachShader(id_, pVShader_->GetId());
        if (pFShader_)
            glDetachShader(id_, pFShader_->GetId());

        pVShader_ = nullptr;
        pFShader_ = nullptr;
        glDeleteProgram(id_);

        if (Graphics::this_->GetProgram() == this)
            Graphics::this_->SetProgram(nullptr);

        nBones_ = 0;
        nDirectionalLights_ = 0;
        nPointLights_ = 0;
        nSpotLights_ = 0;

        activeDirectionalLights_.clear();
        activePointLights_.clear();
        activeSpotLights_.clear();

        activeCamera_ = nullptr;
        viewVariablesNeverSet_ = true;
        materialVariablesNeverSet_ = true;
        activeSkeleton_ = nullptr;
        activeNode_ = nullptr;
        activeScene_ = nullptr;
        sceneColor_ = Color(-1);

        bonesBaseLoc_.clear();
        pointLightsLoc_.clear();
        directionalLightsLoc_.clear();
        spotLightsLoc_.clear();

        Graphics::this_->InvalidateVAOFor(this);
    }

    std::string Program::TranslateFlags() const
    {
        std::string ss;

        if (material_->IsBatched())
            ss += " INSTANCED";

        if (!flags_)
        {
            ss += " VERTEX_COLOR";
        }
        else
        {
            if ((int)ProgramFlag::PER_VERTEX_LIGHTING & flags_)
                ss += " PER_VERTEX_LIGHTING";
            if ((int)ProgramFlag::PER_PIXEL_LIGHTING & flags_)
                ss += " PER_PIXEL_LIGHTING";
            if ((int)ProgramFlag::BLEND & flags_)
                ss += " BLEND";
            if ((int)ProgramFlag::BLUR & flags_)
                ss += " BLUR";
            if ((int)ProgramFlag::WAVE & flags_)
                ss += " WAVE";
            if ((int)ProgramFlag::TEXT & flags_)
                ss += " TEXT";
            if ((int)ProgramFlag::SHOW_TEXTURE0 & flags_)
                ss += " SHOW_TEXTURE0";
            if ((int)ProgramFlag::FLIP_Y & flags_)
                ss += " FLIP_Y";
            if ((int)ProgramFlag::STENCIL & flags_)
                ss += " STENCIL";
            if ((int)ProgramFlag::NORMALMAP & flags_)
                ss += " NORMALMAP";
            if ((int)ProgramFlag::LIGHTMAP & flags_)
                ss += " LIGHTMAP";
            if ((int)ProgramFlag::UNLIT & flags_)
                ss += " UNLIT";
            if ((int)ProgramFlag::SKINNED & flags_)
            {
                ss += " SKINNED";
                std::stringstream s;
                s << nBones_;
                ss += " NUM_BONES=" + s.str();
            }
            if ((int)ProgramFlag::SPECULARMAP & flags_)
                ss += " SPECULARMAP";
            if ((int)ProgramFlag::AOMAP & flags_)
                ss += " AOMAP";
            if ((int)ProgramFlag::DISPLACEMENTMAP & flags_)
                ss += " DISPLACEMENTMAP";
            if ((int)ProgramFlag::DIFFUSEMAP & flags_)
                ss += " DIFFUSEMAP";
            if ((int)ProgramFlag::SPHERICAL_BILLBOARD & flags_)
                ss += " SPHERICAL_BILLBOARD";
            if ((int)ProgramFlag::CYLINDRICAL_BILLBOARD & flags_)
                ss += " CYLINDRICAL_BILLBOARD";
        }

        return ss;
    }

    bool Program::ShaderCompiles(GLenum type, const std::string& buffer) const
    {
        CHECK_GL_STATUS(__FILE__, __LINE__);
        GLuint id = glCreateShader(type);
        const char* source = buffer.c_str();
        glShaderSource(id, 1, &source, nullptr);
        glCompileShader(id);
        GLint compile_status = GL_FALSE;
        glGetShaderiv(id, GL_COMPILE_STATUS, &compile_status);
        if (compile_status != GL_TRUE)
        {
            GLint logLength = 0;
            glGetShaderiv(id, GL_INFO_LOG_LENGTH, &logLength);
            if (logLength > 0)
            {
                std::string log;
                log.resize(logLength);
                glGetShaderInfoLog(id, logLength, &logLength, &log[0]);
                TRACE_LOG(log);
            }
        }
        glDeleteShader(id);
        //glReleaseShaderCompiler(); // fails on osx
        CHECK_GL_STATUS(__FILE__, __LINE__);
        TRACE_LOG("Checking " << (type == GL_VERTEX_SHADER ? "VERTEX" : "FRAGMENT") << " shader for material " << name_ << " with flags =" << TranslateFlags() << ":" << (compile_status == GL_TRUE ? "IS OK" : "HAS FAILED"));

        return compile_status == GL_TRUE;
    }

    void Program::ReduceShaderComplexity(GLenum type)
    {
        //TRACE_LOG("!!!Shader does not compile. Type=" << (type == GL_VERTEX_SHADER ? "Vertex" : "Fragment"));

        if ((int)ProgramFlag::DISPLACEMENTMAP & flags_)
        {
            TRACE_LOG("Reducing complexity: removing DISPLACEMENTMAP");
            flags_ &= ~(int)ProgramFlag::DISPLACEMENTMAP;
        }
        else if ((int)ProgramFlag::SPECULARMAP & flags_)
        {
            TRACE_LOG("Reducing complexity: removing SPECULARMAP");
            flags_ &= ~(int)ProgramFlag::SPECULARMAP;
        }
        else if ((int)ProgramFlag::AOMAP & flags_)
        {
            TRACE_LOG("Reducing complexity: removing SPECULARMAP");
            flags_ &= ~(int)ProgramFlag::AOMAP;
        }
        else if ((int)ProgramFlag::NORMALMAP & flags_)
        {
            TRACE_LOG("Reducing complexity: removing NORMALMAP");
            flags_ &= ~(int)ProgramFlag::NORMALMAP;
        }
        else if (GL_FRAGMENT_SHADER == type && (int)ProgramFlag::PER_PIXEL_LIGHTING & flags_)
        {
            TRACE_LOG("Reducing complexity: removing PER_PIXEL_LIGHTING, adding PER_VERTEX_LIGHTING");
            flags_ &= ~(int)ProgramFlag::PER_PIXEL_LIGHTING;
            flags_ |= (int)ProgramFlag::PER_VERTEX_LIGHTING;
        }
        else if (GL_VERTEX_SHADER == type && material_->GetDiffuseMap() != nullptr && (int)ProgramFlag::PER_VERTEX_LIGHTING & flags_)
        {
            TRACE_LOG("Reducing complexity: removing PER_VERTEX_LIGHTING, adding UNLIT");
            flags_ &= ~(int)ProgramFlag::PER_VERTEX_LIGHTING;
            flags_ |= (int)ProgramFlag::UNLIT;
        }
        else if ((int)ProgramFlag::PER_PIXEL_LIGHTING & flags_)
        {
            TRACE_LOG("Reducing complexity: removing PER_PIXEL_LIGHTING, changing to VERTEX_COLOR");
            flags_ = (int)ProgramFlag::NONE;
        }
        else if ((int)ProgramFlag::PER_VERTEX_LIGHTING & flags_)
        {
            TRACE_LOG("Reducing complexity: removing PER_VERTEX_LIGHTING, changing to VERTEX_COLOR");
            flags_ = (int)ProgramFlag::NONE;
        }
        else if ((int)ProgramFlag::UNLIT & flags_)
        {
            TRACE_LOG("Reducing complexity: removing UNLIT, changing to VERTEX_COLOR");
            flags_ = (int)ProgramFlag::NONE;
        }
        else if ((int)ProgramFlag::SKINNED & flags_)
        {
            TRACE_LOG("Reducing complexity: removing SKINNED");
            flags_ &= ~(int)ProgramFlag::SKINNED;
            nBones_ = 0;
        }
        else
        {
            TRACE_LOG("!!! Cannot reduce complexity");
            throw std::runtime_error("!!! Cannot reduce complexity");
        }
    }

    void Program::SetUniformLocations()
    {
        CHECK_GL_STATUS(__FILE__, __LINE__);

        att_positionLoc_ = GetAttributeLocation("a_position");
        att_normalLoc_ = GetAttributeLocation("a_normal");
        att_texcoordLoc0_ = GetAttributeLocation("a_texcoord0");
        att_texcoordLoc1_ = GetAttributeLocation("a_texcoord1");
        att_colorLoc_ = GetAttributeLocation("a_color");
        att_tangentLoc_ = GetAttributeLocation("a_tangent");
        att_bonesIDLoc_ = GetAttributeLocation("a_boneIDs");
        att_bonesWeightLoc_ = GetAttributeLocation("a_weights");

        att_modelMatrixRow0Loc_ = GetAttributeLocation("a_mMatrixRow0");
        att_normalMatrixCol0Loc_ = GetAttributeLocation("a_normalMatrixCol0");

        modelLoc_ = GetUniformLocation("u_model");
        normalMatrixLoc_ = GetUniformLocation("u_normalMatrix");
        viewLoc_ = GetUniformLocation("u_view");
        viewProjectionLoc_ = GetUniformLocation("u_viewProjection");
        projectionLoc_  = GetUniformLocation("u_projection");
        sceneColorAmbientLoc_ = GetUniformLocation("u_sceneAmbientColor");
        eyeWorldPosLoc_ = GetUniformLocation("u_eyeWorldPos");
        for (size_t index = 0; index < MaterialTexture::MAX_TEXTURES_MAPS; index++)
        {
            std::stringstream ss;
            ss << "u_texture" << index;
            textureLoc_[index] = GetUniformLocation(ss.str().c_str());
        }
        materialLoc_.color_ = GetUniformLocation("u_material.color");
        materialLoc_.ambient_ = GetUniformLocation("u_material.ambient");
        materialLoc_.diffuse_ = GetUniformLocation("u_material.diffuse");
        materialLoc_.specular_ = GetUniformLocation("u_material.specular");
        materialLoc_.shininess_ = GetUniformLocation("u_material.shininess");
        materialLoc_.parallaxScale_ = GetUniformLocation("u_material.parallaxScale");

        for (size_t i = 0; i < nBones_; i++)
        {
            std::stringstream ss;
            ss << "u_bones[" << i << "]";
            GLuint boneLoc = GetUniformLocation(ss.str().c_str());
            CHECK_ASSERT(boneLoc != -1, __FILE__, __LINE__);
            bonesBaseLoc_.push_back(boneLoc);
        }

        for (unsigned idx = 0; idx < nDirectionalLights_; idx++)
        {
            std::stringstream lightIndex;
            lightIndex << "u_directionalLight[" << idx << "]";

            DirectionalLightLoc directionalLightLoc;
            directionalLightLoc.enabled_ = GetUniformLocation(lightIndex.str() + ".enabled");
            directionalLightLoc.base_.ambient_ = GetUniformLocation(lightIndex.str() + ".base.ambient");
            directionalLightLoc.base_.diffuse_ = GetUniformLocation(lightIndex.str() + ".base.diffuse");
            directionalLightLoc.base_.specular_ = GetUniformLocation(lightIndex.str() + ".base.specular");
            directionalLightLoc.direction_ = GetUniformLocation(lightIndex.str() + ".direction");
            directionalLightsLoc_.push_back(directionalLightLoc);
        }

        for (unsigned idx = 0; idx < nPointLights_; idx++)
        {
            std::stringstream lightIndex;
            lightIndex << "u_pointLights[" << idx << "]";
            PointLightLoc pointLightLoc;
            pointLightLoc.enabled_ = GetUniformLocation(lightIndex.str() + ".enabled");
            pointLightLoc.base_.ambient_ = GetUniformLocation(lightIndex.str() + ".base.ambient");
            pointLightLoc.base_.diffuse_ = GetUniformLocation(lightIndex.str() + ".base.diffuse");
            pointLightLoc.base_.specular_ = GetUniformLocation(lightIndex.str() + ".base.specular");
            pointLightLoc.position_ = GetUniformLocation(lightIndex.str() + ".position");
            pointLightLoc.atten_.constant_ = GetUniformLocation(lightIndex.str() + ".atten.constant");
            pointLightLoc.atten_.linear_ = GetUniformLocation(lightIndex.str() + ".atten.linear");
            pointLightLoc.atten_.quadratic_ = GetUniformLocation(lightIndex.str() + ".atten.quadratic");
            pointLightsLoc_.push_back(pointLightLoc);
        }

        for (unsigned idx = 0; idx < nSpotLights_; idx++)
        {
            std::stringstream lightIndex;
            lightIndex << "u_spotLights[" << idx << "]";
            SpotLightLoc spotLightLoc;
            spotLightLoc.enabled_ = GetUniformLocation(lightIndex.str() + ".enabled");
            spotLightLoc.base_.ambient_ = GetUniformLocation(lightIndex.str() + ".base.ambient");
            spotLightLoc.base_.diffuse_ = GetUniformLocation(lightIndex.str() + ".base.diffuse");
            spotLightLoc.base_.specular_ = GetUniformLocation(lightIndex.str() + ".base.specular");
            spotLightLoc.position_ = GetUniformLocation(lightIndex.str() + ".position");
            spotLightLoc.atten_.constant_ = GetUniformLocation(lightIndex.str() + ".atten.constant");
            spotLightLoc.atten_.linear_ = GetUniformLocation(lightIndex.str() + ".atten.linear");
            spotLightLoc.atten_.quadratic_ = GetUniformLocation(lightIndex.str() + ".atten.quadratic");
            spotLightLoc.direction_ = GetUniformLocation(lightIndex.str() + ".direction");
            spotLightLoc.cutOff_ = GetUniformLocation(lightIndex.str() + ".cutOff");
            spotLightsLoc_.push_back(spotLightLoc);
        }

        blendMode_loc_ = GetUniformLocation("u_blendMode");
        blurFilterLoc_.blurDir_ = GetUniformLocation("u_blurDir");
        blurFilterLoc_.blurRadius_ = GetUniformLocation("u_blurRadius");
        blurFilterLoc_.sigma_ = GetUniformLocation("u_sigma");
        wavesFilterLoc_.factor_ = GetUniformLocation("u_waveFactor");
        wavesFilterLoc_.offset_ = GetUniformLocation("u_waveOffset");

        for (int index = 0; index < MaterialTexture::MAX_TEXTURES_MAPS; index++)
        {
            if (textureLoc_[index] != -1)
                glUniform1i(textureLoc_[index], index); //set fixed locations for samplers
        }

        CHECK_GL_STATUS(__FILE__, __LINE__);
    }

    bool Program::Initialize()
    {
        CHECK_GL_STATUS(__FILE__, __LINE__);
        TRACE_LOG("Creating program for material " << name_);
        id_ = glCreateProgram();
        // Bind vertex attribute locations to ensure they are the same in all shaders
        glBindAttribLocation(id_, (int)AttributesLoc::POSITION, "a_position");
        glBindAttribLocation(id_, (int)AttributesLoc::NORMAL, "a_normal");
        glBindAttribLocation(id_, (int)AttributesLoc::TEXTURECOORD0, "a_texcoord0");
        glBindAttribLocation(id_, (int)AttributesLoc::TEXTURECOORD1, "a_texcoord1");
        glBindAttribLocation(id_, (int)AttributesLoc::COLOR, "a_color");
        glBindAttribLocation(id_, (int)AttributesLoc::TANGENT, "a_tangent");
        glBindAttribLocation(id_, (int)AttributesLoc::BONES_ID, "a_boneIDs");
        glBindAttribLocation(id_, (int)AttributesLoc::BONES_WEIGHT, "a_weights");
        glBindAttribLocation(id_, (int)AttributesLoc::MODEL_MATRIX_ROW0, "a_mMatrixRow0");
        glBindAttribLocation(id_, (int)AttributesLoc::MODEL_MATRIX_ROW1, "a_mMatrixRow1");
        glBindAttribLocation(id_, (int)AttributesLoc::MODEL_MATRIX_ROW2, "a_mMatrixRow2");
        glBindAttribLocation(id_, (int)AttributesLoc::NORMAL_MATRIX_COL0, "a_normalMatrixCol0");
        glBindAttribLocation(id_, (int)AttributesLoc::NORMAL_MATRIX_COL1, "a_normalMatrixCol1");
        glBindAttribLocation(id_, (int)AttributesLoc::NORMAL_MATRIX_COL2, "a_normalMatrixCol2");
        glAttachShader(id_, pVShader_->GetId());
        glAttachShader(id_, pFShader_->GetId());
        glLinkProgram(id_);
        GLint link_status = GL_FALSE;
        glGetProgramiv(id_, GL_LINK_STATUS, &link_status);
        if (link_status != GL_TRUE)
        {
            GLint logLength = 0;
            glGetProgramiv(id_, GL_INFO_LOG_LENGTH, &logLength);
            if (logLength > 0)
            {
                std::string log;
                log.resize(logLength);
                glGetProgramInfoLog(id_, logLength, &logLength, &log[0]);
                TRACE_LOG("Error in Program Creation: " << log);
                //TRACE_LOG("VS: " << pVShader_->GetSource());
                //TRACE_LOG("FS: " << pFShader_->GetSource());
            }
            TRACE_LOG("Linking program for material " << name_ << " HAS FAILED!!!");
            return false;
        }
        TRACE_LOG("Program for material " << name_ << " OK.");
        CHECK_GL_STATUS(__FILE__, __LINE__);
        return true;
    }

    GLuint Program::GetAttributeLocation(const std::string& name)
    {
        return glGetAttribLocation(id_, name.c_str());
    }

    GLuint Program::GetUniformLocation(const std::string& name)
    {
        return glGetUniformLocation(id_, name.c_str());
    }

    void Program::SetSceneVariables(Scene* scene)
    {
        if (sceneColorAmbientLoc_ != -1)
        {
            if (scene)
            {
                if (activeScene_ != scene || scene->UniformsNeedUpdate())
                    glUniform4fv(sceneColorAmbientLoc_, 1, &scene->GetAmbientColor()[0]);
            }
            else if (activeScene_ != scene || sceneColor_ == Color(-1))
            {
                sceneColor_ = Color(0, 0, 0, 1);
                glUniform4fv(sceneColorAmbientLoc_, 1, &sceneColor_[0]);
            }

            activeScene_ = scene;
        }
    }

    void Program::SetNodeVariables(Node* node)
    {
        if (node && (activeNode_ != node || node->UniformsNeedUpdate()))
        {
            if (modelLoc_ != -1)
            {
                const Matrix4& m = node->GetGlobalModelMatrix();
                glUniformMatrix4fv(modelLoc_, 1, GL_FALSE, glm::value_ptr(m));
            }

            if (normalMatrixLoc_ != -1)
            {
                const Matrix3& m = node->GetGlobalModelInvTranspMatrix();
                glUniformMatrix3fv(normalMatrixLoc_, 1, GL_FALSE, glm::value_ptr(m));
            }

            activeNode_ = node;
        }
    }

    void Program::SetMaterialVariables()
    {
        if (material_)
        {
            for (int index = 0; index < MaterialTexture::MAX_TEXTURES_MAPS; index++)
                if (textureLoc_[index] != -1)
                    Graphics::this_->SetTexture(index, material_->GetTexture(index).get());

            if (materialVariablesNeverSet_ || material_->UniformsNeedUpdate())
            {
                materialVariablesNeverSet_ = false;

                if (materialLoc_.color_ != -1)
                    glUniform4fv(materialLoc_.color_, 1, &material_->color_[0]);

                if (materialLoc_.ambient_ != -1)
                    glUniform4fv(materialLoc_.ambient_, 1, &material_->ambient_[0]);

                if (materialLoc_.diffuse_ != -1)
                    glUniform4fv(materialLoc_.diffuse_, 1, &material_->diffuse_[0]);

                if (materialLoc_.specular_ != -1)
                    glUniform4fv(materialLoc_.specular_, 1, &material_->specular_[0]);

                if (materialLoc_.shininess_ != -1)
                    glUniform1f(materialLoc_.shininess_, material_->shininess_);

                if (materialLoc_.parallaxScale_ != -1)
                    glUniform1f(materialLoc_.parallaxScale_, material_->parallaxScale_);

                if (blendMode_loc_ != -1)
                    glUniform1i(blendMode_loc_, (int)material_->GetFilterBlendMode());

                if (blurFilterLoc_.blurDir_ != -1)
                    glUniform2fv(blurFilterLoc_.blurDir_, 1, &material_->blurFilter_.blurDir_[0]);

                if (blurFilterLoc_.blurRadius_ != -1)
                    glUniform2fv(blurFilterLoc_.blurRadius_, 1, &material_->blurFilter_.blurRadius_[0]);

                if (blurFilterLoc_.sigma_ != -1)
                    glUniform1f(blurFilterLoc_.sigma_, material_->blurFilter_.sigma_);

                if (wavesFilterLoc_.factor_ != -1)
                    glUniform1f(wavesFilterLoc_.factor_, material_->waveFilter_.factor_);

                if (wavesFilterLoc_.offset_ != -1)
                    glUniform1f(wavesFilterLoc_.offset_, material_->waveFilter_.offset_);

            }
        }
    }

    bool Program::SetSkeletonVariables(Skeleton* skeleton)
    {
        CHECK_CONDITION((skeleton || nBones_ == 0) && "Invalid shader. This shader has been used for skin animation and cannot be reused by an object without skeleton.", __FILE__, __LINE__);

        CHECK_GL_STATUS(__FILE__, __LINE__);

        if (skeleton && IsSkinned())
        {
            const std::vector<PWeakNode>& bones = skeleton->GetBones();
            size_t nBones = bones.size();
            if (nBones > nBones_)
            {
                TRACE_LOG("Invalidating program " << name_ << " for material " << material_->GetName() << " since number of bones (in the shader) has increased. Before nBones = " << nBones_ << ", now is " << nBones << ".");
                Invalidate();
                nBones_ = nBones;
                return false;
            }

            PNode rootNode = skeleton->GetRoot().lock();
            Matrix4 globalInverseModelMatrix(1);
            PNode parent = rootNode->GetParent();
            if (parent)
            {
                // In order to make all the bones relatives to the root's parent.
                // The model matrix and normal matrix for the active node is premultiplied in the shader (see Program::SetNodeVariables)
                // See in Transform.glsl: GetModelMatrix() and GetWorldNormal()
                globalInverseModelMatrix = parent->GetGlobalModelInvMatrix();
            }

            for (unsigned idx = 0; idx < nBones; idx++)
            {
                GLuint boneLoc = bonesBaseLoc_[idx];

                Node* bone = bones[idx].lock().get();
                if (activeSkeleton_ != skeleton || bone->UniformsNeedUpdate())
                {
                    // Be careful, bones don't have normal matrix so their scale must be uniform (sx == sy == sz)
                    CHECK_ASSERT(bone->IsScaleUniform(), __FILE__, __LINE__);
                    const Matrix4& m = bone->GetGlobalModelMatrix();
                    const Matrix4& offsetMatrix = bone->GetBoneOffsetMatrix();
                    Matrix4 boneMatrix(globalInverseModelMatrix * m * offsetMatrix);
                    glUniformMatrix4fv(boneLoc, 1, GL_FALSE, glm::value_ptr(boneMatrix));
                }
            }
        }

        activeSkeleton_ = skeleton;

        CHECK_GL_STATUS(__FILE__, __LINE__);

        return true;
    }

    void Program::SetCameraVariables()
    {
        if (viewLoc_ != -1 || viewProjectionLoc_ != -1 || projectionLoc_ != -1 || eyeWorldPosLoc_ != -1)
        {
            Camera* camera = Graphics::this_->GetCamera();
            bool update_camera = viewVariablesNeverSet_ || (activeCamera_ != camera || (camera && camera->UniformsNeedUpdate()));

            if (update_camera)
            {
                viewVariablesNeverSet_ = false;

                if (viewProjectionLoc_ != -1)
                {
                    const Matrix4& m = Camera::GetMatViewProj();
                    glUniformMatrix4fv(viewProjectionLoc_, 1, GL_FALSE, glm::value_ptr(m));
                }

                if (viewLoc_ != -1)
                {
                    const Matrix4& m = Camera::GetViewMatrix();
                    glUniformMatrix4fv(viewLoc_, 1, GL_FALSE, glm::value_ptr(m));
                }

                if (projectionLoc_ != -1)
                {
                    const Matrix4& m = Camera::GetProjectionMatrix();
                    glUniformMatrix4fv(projectionLoc_, 1, GL_FALSE, glm::value_ptr(m));
                }


                if (eyeWorldPosLoc_ != -1)
                {
                    Vertex3 position(0);
                    if (camera)
                        position = camera->GetGlobalPosition();
                    glUniform3fv(eyeWorldPosLoc_, 1, &position[0]);
                }
            }

            activeCamera_ = camera;
        }
    }

    void Program::SetBaseLightVariables(const BaseLightLoc& baseLoc, const Light* light)
    {
        if (baseLoc.ambient_ != -1)
        {
            const Color& ambient = light->GetAmbientColor();
            glUniform4fv(baseLoc.ambient_, 1, &ambient[0]);
        }

        if (baseLoc.diffuse_ != -1)
        {
            const Color& diffuse = light->GetDiffuseColor();
            glUniform4fv(baseLoc.diffuse_, 1, &diffuse[0]);
        }

        if (baseLoc.specular_ != -1)
        {
            const Color& specular = light->GetSpecularColor();
            glUniform4fv(baseLoc.specular_, 1, &specular[0]);
        }
    }

    bool Program::SetLightVariables(Scene* scene)
    {
        if (lightingEnabled_ && scene)
        {
            auto& dirLights = scene->GetLights(LightType::DIRECTIONAL);

            if (nDirectionalLights_ != dirLights.size())
            {
                if (nDirectionalLights_ > dirLights.size() || !directionalLightsReduced_)
                {
                    TRACE_LOG("Invalidating program due number of directionals light has changed!!!");
                    Invalidate();
                    return false;
                }
            }

            auto& pointLigths = scene->GetLights(LightType::POINT);

            if (nPointLights_ != pointLigths.size())
            {
                if (nPointLights_ > pointLigths.size() || !pointLightsReduced_)
                {
                    TRACE_LOG("Invalidating program due number of points light has changed!!!");
                    Invalidate();
                    return false;
                }
            }

            auto& spotLigths = scene->GetLights(LightType::SPOT);

            if (nSpotLights_ != spotLigths.size())
            {
                if (nSpotLights_ > spotLigths.size() || !spotLightsReduced_)
                {
                    TRACE_LOG("Invalidating program due number of spot light has changed!!!");
                    Invalidate();
                    return false;
                }
            }

            for (unsigned idx = 0; idx < nDirectionalLights_; idx++)
            {
                const Light* light = dirLights[idx].lock().get();

                if (light && (activeDirectionalLights_[idx] != light || light->UniformsNeedUpdate()))
                {
                    const DirectionalLightLoc& loc = directionalLightsLoc_[idx];

                    SetBaseLightVariables(loc.base_, light);

                    if (loc.enabled_ != -1)
                    {
                        glUniform1i(loc.enabled_, light->IsEnabled() ? 1 : 0);
                    }

                    if (loc.direction_ != -1)
                    {
                        const Vertex3& direction = light->GetLookAtDirection();
                        glUniform3fv(loc.direction_, 1, &direction[0]);
                    }
                }

                activeDirectionalLights_[idx] = light;
            }

            for (unsigned idx = 0; idx < nPointLights_; idx++)
            {
                const Light* light = pointLigths[idx].lock().get();

                if (light && (activePointLights_[idx] != light || light->UniformsNeedUpdate()))
                {
                    const PointLightLoc& loc = pointLightsLoc_[idx];

                    SetBaseLightVariables(loc.base_, light);

                    if (loc.enabled_ != -1)
                    {
                        glUniform1i(loc.enabled_, light->IsEnabled() ? 1 : 0);
                    }

                    if (loc.position_ != -1)
                    {
                        const Vertex3& position = light->GetGlobalPosition();
                        glUniform3fv(loc.position_, 1, &position[0]);
                    }

                    const Light::Attenuation& attenuation = light->GetAttenuation();

                    if (loc.atten_.constant_ != -1)
                    {
                        glUniform1f(loc.atten_.constant_, attenuation.constant);
                    }

                    if (loc.atten_.linear_  != -1)
                    {
                        glUniform1f(loc.atten_.linear_, attenuation.linear);
                    }

                    if (loc.atten_.quadratic_ != -1)
                    {
                        glUniform1f(loc.atten_.quadratic_, attenuation.quadratic);
                    }
                }

                activePointLights_[idx] = light;
            }

            for (unsigned idx = 0; idx < nSpotLights_; idx++)
            {
                const Light* light = spotLigths[idx].lock().get();

                if (light && (activeSpotLights_[idx] != light || light->UniformsNeedUpdate()))
                {
                    const SpotLightLoc& loc = spotLightsLoc_[idx];

                    SetBaseLightVariables(loc.base_, light);

                    if (loc.enabled_ != -1)
                    {
                        glUniform1i(loc.enabled_, light->IsEnabled() ? 1 : 0);
                    }

                    if (loc.position_ != -1)
                    {
                        const Vertex3& position = light->GetGlobalPosition();
                        glUniform3fv(loc.position_, 1, &position[0]);
                    }

                    if (loc.atten_.constant_ != -1)
                    {
                        const Light::Attenuation& attenuation = light->GetAttenuation();
                        glUniform1f(loc.atten_.constant_, attenuation.constant);
                    }

                    if (loc.atten_.linear_  != -1)
                    {
                        const Light::Attenuation& attenuation = light->GetAttenuation();
                        glUniform1f(loc.atten_.linear_, attenuation.linear);
                    }

                    if (loc.atten_.quadratic_ != -1)
                    {
                        const Light::Attenuation& attenuation = light->GetAttenuation();
                        glUniform1f(loc.atten_.quadratic_, attenuation.quadratic);
                    }

                    if (loc.direction_ != -1)
                    {
                        const Vertex3& direction = light->GetLookAtDirection();
                        glUniform3fv(loc.direction_, 1, &direction[0]);
                    }

                    if (loc.cutOff_ != -1)
                    {
                        float cutOff = light->GetSpotCutOff() * 0.5f;
                        float value = glm::cos(glm::radians(cutOff));
                        glUniform1f(loc.cutOff_, value);
                    }
                }

                activeSpotLights_[idx] = light;
            }
        }

        return true;
    }

    void Program::SetVariables(Mesh* mesh, Node* node)
    {
        if (SetSkeletonVariables(mesh->GetSkeleton().get()))
        {
            Scene* scene = Graphics::this_->GetScene();
            SetSceneVariables(scene);
            SetMaterialVariables();
            SetNodeVariables(node);
            SetCameraVariables();
            SetLightVariables(scene);
        }
    }

    void Program::Save(pugi::xml_node& node)
    {
        pugi::xml_node child = node.append_child("Program");
        child.append_attribute("flags") = flags_.to_string().c_str();
    }

    void Program::SetFlags(const ProgramFlags& flags)
    {
        if (flags_ != flags)
        {
            flags_ = flags;
            int needsMaterial = flags & ((int)ProgramFlag::BLEND | (int)ProgramFlag::BLUR | (int)ProgramFlag::WAVE | (int)ProgramFlag::TEXT | (int)ProgramFlag::SHOW_TEXTURE0 |
                                         (int)ProgramFlag::NORMALMAP | (int)ProgramFlag::LIGHTMAP | (int)ProgramFlag::UNLIT | (int)ProgramFlag::SPECULARMAP |
                                         (int)ProgramFlag::AOMAP | (int)ProgramFlag::DISPLACEMENTMAP | (int)ProgramFlag::DIFFUSEMAP);
            CHECK_CONDITION((!needsMaterial || material_) && "Program needs material but it does not have one!!!", __FILE__, __LINE__);
            Invalidate();
        }
    }

    void Program::EnableFlags(const ProgramFlags& flags)
    {
        SetFlags(flags_ | (int)flags);
    }

    void Program::DisableFlags(const ProgramFlags& flags)
    {
        SetFlags(flags_ & ~(int)flags);
    }

}
